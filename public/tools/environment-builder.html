<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Environment Builder - LimeZu</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: #2a2a4a;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            border-bottom: 1px solid #444;
        }
        .header h1 {
            color: #b5a589;
            font-size: 20px;
        }
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .header-controls label {
            color: #888;
            font-size: 12px;
        }
        .header-controls input, .header-controls select {
            padding: 5px 8px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #eee;
            border-radius: 3px;
            width: 60px;
        }
        .header-controls select { width: auto; }
        .header-controls button {
            padding: 8px 16px;
            background: #4a7c4e;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-weight: 500;
        }
        .header-controls button:hover { background: #5a9c5e; }
        .header-controls button.danger { background: #7c4a4a; }
        .header-controls button.danger:hover { background: #9c5a5a; }

        /* Main layout */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left panel - Tile palette */
        .palette-panel {
            width: 600px;
            min-width: 500px;
            background: #252545;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }
        .palette-header {
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        .palette-header h3 {
            color: #b5a589;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .layer-tabs {
            display: flex;
            gap: 5px;
        }
        .layer-tab {
            padding: 6px 12px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 12px;
        }
        .layer-tab.active {
            background: #3a3a6a;
            color: #fff;
            border-color: #b5a589;
        }
        .tileset-select {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .tileset-select select {
            flex: 1;
            padding: 6px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #eee;
            border-radius: 3px;
        }
        .tileset-select label {
            font-size: 12px;
            color: #888;
        }
        .palette-tiles {
            flex: 1;
            overflow: auto;
            padding: 10px;
            background: #1a1a2e;
        }
        .tileset-wrapper {
            position: relative;
            display: inline-block;
            cursor: crosshair;
        }
        .tileset-image {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .tileset-grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .tileset-hover {
            position: absolute;
            border: 2px solid #ffcc00;
            background: rgba(255, 204, 0, 0.2);
            pointer-events: none;
            display: none;
        }
        .tileset-selected {
            position: absolute;
            border: 3px solid #00ff88;
            background: rgba(0, 255, 136, 0.3);
            pointer-events: none;
            display: none;
        }
        .selected-preview {
            padding: 10px;
            border-top: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 10px;
            background: #252545;
        }
        .selected-preview canvas {
            image-rendering: pixelated;
            border: 1px solid #444;
        }
        .selected-info {
            font-size: 12px;
            color: #888;
        }

        /* Center - Room canvas */
        .canvas-panel {
            flex: 1;
            overflow: auto;
            background: #111;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 20px;
        }
        .canvas-container {
            position: relative;
            border: 2px solid #444;
        }
        #roomCanvas {
            display: block;
            image-rendering: pixelated;
            cursor: crosshair;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* Right panel - Export */
        .export-panel {
            width: 350px;
            background: #252545;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
        }
        .export-header {
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        .export-header h3 {
            color: #b5a589;
            font-size: 14px;
        }
        .export-options {
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        .export-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }
        .export-options input[type="text"] {
            flex: 1;
            padding: 5px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #eee;
            border-radius: 3px;
        }
        .export-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .export-code {
            flex: 1;
            background: #1a1a2e;
            border: none;
            color: #88ff88;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            padding: 10px;
            resize: none;
        }
        .export-buttons {
            padding: 10px;
            display: flex;
            gap: 10px;
        }
        .export-buttons button {
            flex: 1;
            padding: 10px;
            background: #4a5a7c;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
        }
        .export-buttons button:hover { background: #5a6a9c; }
        .export-buttons button.primary { background: #4a7c4e; }
        .export-buttons button.primary:hover { background: #5a9c5e; }

        /* Tools */
        .tools-bar {
            padding: 10px;
            border-bottom: 1px solid #444;
            display: flex;
            gap: 5px;
        }
        .tool-btn {
            padding: 8px 12px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 12px;
        }
        .tool-btn:hover { border-color: #666; }
        .tool-btn.active {
            background: #3a3a6a;
            color: #fff;
            border-color: #b5a589;
        }

        /* Wall tool options */
        .wall-options {
            padding: 10px;
            border-bottom: 1px solid #444;
            display: none;
        }
        .wall-options.visible { display: block; }
        .wall-options label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        .wall-options input {
            width: 60px;
            padding: 4px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #eee;
            border-radius: 3px;
        }

        /* Status bar */
        .status-bar {
            background: #2a2a4a;
            padding: 5px 15px;
            font-size: 12px;
            color: #888;
            border-top: 1px solid #444;
        }

        /* Load modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.visible { display: flex; }
        .modal {
            background: #252545;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal h2 {
            color: #b5a589;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .modal textarea {
            flex: 1;
            min-height: 300px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #88ff88;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            padding: 10px;
            resize: none;
            border-radius: 4px;
        }
        .modal-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        .modal-buttons .cancel { background: #4a4a6a; color: #ccc; }
        .modal-buttons .cancel:hover { background: #5a5a7a; }
        .modal-buttons .load { background: #4a7c4e; color: #fff; }
        .modal-buttons .load:hover { background: #5a9c5e; }
        .modal .error { color: #ff6666; font-size: 12px; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Environment Builder</h1>
        <div class="header-controls">
            <label>Width: <input type="number" id="roomWidth" value="20" min="5" max="100"></label>
            <label>Height: <input type="number" id="roomHeight" value="15" min="5" max="100"></label>
            <label>Tile Size:
                <select id="tileDisplaySize">
                    <option value="16">16px</option>
                    <option value="24">24px</option>
                    <option value="32" selected>32px</option>
                    <option value="48">48px</option>
                </select>
            </label>
            <button onclick="resizeRoom()">Apply Size</button>
            <select id="existingRooms" onchange="loadExistingRoom(this.value)">
                <option value="">-- Load Zone --</option>
            </select>
            <button onclick="refreshServerZones()" title="Refresh zones list">↻</button>
            <button onclick="showLoadModal()">Import Code</button>
            <button class="danger" onclick="clearRoom()">Clear All</button>
            <span style="margin-left:20px;border-left:1px solid #555;padding-left:20px;">
                <input type="text" id="zoneId" placeholder="zone-name" style="width:100px;" value="my-zone">
                <button onclick="saveToServer()" style="background:#4a7c4e;">Save to Server</button>
            </span>
        </div>
    </div>

    <!-- Load Room Modal -->
    <div class="modal-overlay" id="loadModal">
        <div class="modal">
            <h2>Load Room Data</h2>
            <p style="color:#888;font-size:12px;margin-bottom:10px;">Paste exported room code (FLOOR, OBJECTS, or WALLS constants):</p>
            <textarea id="loadCodeInput" placeholder="// Paste your exported code here...
const MYZONE_FLOOR = {
    width: 20,
    height: 15,
    tiles: [
        { x: 0, y: 0, tileset: 'floors', tileX: 9, tileY: 7 },
        ...
    ]
};"></textarea>
            <div class="error" id="loadError"></div>
            <div class="modal-buttons">
                <button class="cancel" onclick="hideLoadModal()">Cancel</button>
                <button class="load" onclick="loadRoomData()">Load</button>
            </div>
        </div>
    </div>

    <div class="main">
        <!-- Left: Tile Palette -->
        <div class="palette-panel">
            <div class="palette-header">
                <h3>Tiles</h3>
                <div class="layer-tabs">
                    <div class="layer-tab active" data-layer="floor">Floor</div>
                    <div class="layer-tab" data-layer="walls">Walls</div>
                    <div class="layer-tab" data-layer="objects">Objects</div>
                    <div class="layer-tab" data-layer="portals">Portals</div>
                    <div class="layer-tab" data-layer="enemies">Enemies</div>
                    <div class="layer-tab" data-layer="npcs">NPCs</div>
                </div>
                <div class="tileset-select">
                    <select id="tilesetSelect"></select>
                    <label>Scale:
                        <select id="paletteScale">
                            <option value="2" selected>2x</option>
                            <option value="3">3x</option>
                            <option value="4">4x</option>
                        </select>
                    </label>
                </div>
            </div>
            <div class="tools-bar">
                <button class="tool-btn active" data-tool="paint">Paint</button>
                <button class="tool-btn" data-tool="fill">Fill</button>
                <button class="tool-btn" data-tool="erase">Erase</button>
                <span style="color:#444;margin:0 5px;">|</span>
                <button class="tool-btn" id="flipHBtn" title="Flip Horizontal">FlipH</button>
                <button class="tool-btn" id="flipVBtn" title="Flip Vertical">FlipV</button>
                <span style="color:#444;margin:0 5px;">|</span>
                <button class="tool-btn" id="physicalBtn" title="Object has collision (Objects layer only)">Physical</button>
            </div>
            <div class="wall-options" id="wallOptions">
                <label>Wall Thickness: <input type="number" id="wallThickness" value="50" min="10" max="200"> px</label>
            </div>
            <div class="wall-options" id="portalOptions">
                <label style="color:#4a9;">Portal Mode: Click & drag to create portal hitbox</label>
            </div>
            <div class="wall-options" id="enemyOptions">
                <label style="color:#c44;">Enemy Mode: Click to place, Erase to remove</label>
            </div>
            <div class="wall-options" id="npcOptions">
                <label style="color:#48c;">NPC Mode: Click to place, Erase to remove</label>
            </div>
            <div class="palette-tiles" id="paletteTiles">
                <div class="tileset-wrapper" id="tilesetWrapper">
                    <img class="tileset-image" id="tilesetImage" src="" alt="Tileset">
                    <canvas class="tileset-grid-overlay" id="tilesetGridOverlay"></canvas>
                    <div class="tileset-hover" id="tilesetHover"></div>
                    <div class="tileset-selected" id="tilesetSelected"></div>
                </div>
            </div>
            <div class="selected-preview">
                <canvas id="selectedTilePreview" width="48" height="48"></canvas>
                <div class="selected-info" id="selectedInfo">No tile selected<br><span style="color:#666;font-size:11px">Click a tile above to select</span></div>
            </div>
        </div>

        <!-- Center: Room Canvas -->
        <div class="canvas-panel">
            <div class="canvas-container">
                <canvas id="roomCanvas"></canvas>
                <canvas class="grid-overlay" id="gridOverlay"></canvas>
            </div>
        </div>

        <!-- Right: Export -->
        <div class="export-panel">
            <div class="export-header">
                <h3>Export</h3>
            </div>
            <div class="export-options">
                <label>Zone Name: <input type="text" id="zoneName" value="myZone"></label>
                <label>
                    <input type="checkbox" id="includeWalls" checked> Include walls
                </label>
                <label>
                    <input type="checkbox" id="includeFloor" checked> Include floor tiles
                </label>
                <label>
                    <input type="checkbox" id="includeObjects" checked> Include objects
                </label>
            </div>
            <div class="export-content">
                <textarea class="export-code" id="exportCode" readonly>// Place tiles to generate code</textarea>
            </div>
            <div class="export-buttons">
                <button onclick="copyExport()">Copy Code</button>
                <button class="primary" onclick="updateExport()">Refresh</button>
            </div>
        </div>
    </div>

    <div class="status-bar" id="statusBar">Ready - Click tiles to place</div>

    <script>
        // Tilesets configuration (matching tile-picker)
        const TILESETS = {
            // Room Builder
            floors: { path: '/assets/tiles/Room_Builder_Floors_16x16.png', name: 'RB - Floors' },
            walls: { path: '/assets/tiles/Room_Builder_Walls_16x16.png', name: 'RB - Walls' },
            walls3d: { path: '/assets/tiles/Room_Builder_3d_walls_16x16.png', name: 'RB - 3D Walls' },
            arches: { path: '/assets/tiles/Room_Builder_Arched_Entryways_16x16.png', name: 'RB - Arches' },
            baseboards: { path: '/assets/tiles/Room_Builder_Baseboards_16x16.png', name: 'RB - Baseboards' },
            borders: { path: '/assets/tiles/Room_Builder_borders_16x16.png', name: 'RB - Borders' },
            floorConnectors: { path: '/assets/tiles/Room_Builder_Floor_Connectors_16x16.png', name: 'RB - Floor Connectors' },
            floorPaths: { path: '/assets/tiles/Room_Builder_Floor_Paths_16x16.png', name: 'RB - Floor Paths' },
            floorShadows: { path: '/assets/tiles/Room_Builder_Floor_Shadows_16x16.png', name: 'RB - Floor Shadows' },
            // Theme packs
            t01_generic: { path: '/assets/tiles/1_Generic_16x16.png', name: '01 - Generic' },
            t02_livingRoom: { path: '/assets/tiles/2_LivingRoom_16x16.png', name: '02 - Living Room' },
            t03_bathroom: { path: '/assets/tiles/3_Bathroom_16x16.png', name: '03 - Bathroom' },
            t04_bedroom: { path: '/assets/tiles/4_Bedroom_16x16.png', name: '04 - Bedroom' },
            t05_classroom: { path: '/assets/tiles/5_Classroom_and_library_16x16.png', name: '05 - Classroom' },
            t06_music: { path: '/assets/tiles/6_Music_and_sport_16x16.png', name: '06 - Music & Sport' },
            t07_art: { path: '/assets/tiles/7_Art_16x16.png', name: '07 - Art' },
            t08_gym: { path: '/assets/tiles/8_Gym_16x16.png', name: '08 - Gym' },
            t09_fishing: { path: '/assets/tiles/9_Fishing_16x16.png', name: '09 - Fishing' },
            t10_birthday: { path: '/assets/tiles/10_Birthday_party_16x16.png', name: '10 - Birthday' },
            t11_halloween: { path: '/assets/tiles/11_Halloween_16x16.png', name: '11 - Halloween' },
            t12_kitchen: { path: '/assets/tiles/12_Kitchen_16x16.png', name: '12 - Kitchen' },
            t13_conference: { path: '/assets/tiles/13_Conference_Hall_16x16.png', name: '13 - Conference' },
            t14_basement: { path: '/assets/tiles/14_Basement_16x16.png', name: '14 - Basement' },
            t15_christmas: { path: '/assets/tiles/15_Christmas_16x16.png', name: '15 - Christmas' },
            t16_grocery: { path: '/assets/tiles/16_Grocery_store_16x16.png', name: '16 - Grocery' },
            t17_upstairs: { path: '/assets/tiles/17_Visibile_Upstairs_System_16x16.png', name: '17 - Upstairs' },
            t18_jail: { path: '/assets/tiles/18_Jail_16x16.png', name: '18 - Jail' },
            t19_hospital: { path: '/assets/tiles/19_Hospital_16x16.png', name: '19 - Hospital' },
            t20_japanese: { path: '/assets/tiles/20_Japanese_interiors.png', name: '20 - Japanese' },
            t21_clothing: { path: '/assets/tiles/21_Clothing_Store.png', name: '21 - Clothing' },
            t22_museum: { path: '/assets/tiles/22_Museum.png', name: '22 - Museum' },
            t23_tvStudio: { path: '/assets/tiles/23_Television_and_Film_Studio.png', name: '23 - TV Studio' },
            t24_iceCream: { path: '/assets/tiles/24_Ice_Cream_Shop.png', name: '24 - Ice Cream' },
            t25_shooting: { path: '/assets/tiles/25_Shooting_Range.png', name: '25 - Shooting Range' },
            t26_condo: { path: '/assets/tiles/26_Condominium.png', name: '26 - Condominium' }
        };

        const TILE_SIZE = 16; // Source tile size
        let displayTileSize = 32; // Display size for room canvas
        let paletteScale = 2; // Scale for tileset palette
        let roomWidth = 20;
        let roomHeight = 15;
        let currentLayer = 'floor';
        let currentTool = 'paint';
        let currentTileset = 'floors';
        let selectedTile = null;
        let tilesetImages = {};
        let isDrawing = false;
        let flipH = false;  // Horizontal flip
        let flipV = false;  // Vertical flip
        let physical = false;  // Object has collision

        // Room data
        let roomData = {
            floor: {},    // { "x,y": { tileset, tileX, tileY, flipH, flipV } }
            walls: [],    // [{ x, y, width, height }]
            objects: {},  // { "x,y": { tileset, tileX, tileY, flipH, flipV } }
            portals: [],  // [{ id, x, y, width, height }]
            enemies: [],  // [{ x, y, stationary, passive, hp }]
            npcs: []      // [{ x, y, name, character }]
        };

        // Wall/Portal drawing state
        let wallStart = null;
        let portalStart = null;

        const canvas = document.getElementById('roomCanvas');
        const ctx = canvas.getContext('2d');
        const gridCanvas = document.getElementById('gridOverlay');
        const gridCtx = gridCanvas.getContext('2d');

        // Initialize
        async function init() {
            // Populate tileset dropdown
            const select = document.getElementById('tilesetSelect');
            for (const [key, ts] of Object.entries(TILESETS)) {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = ts.name;
                select.appendChild(opt);
            }

            // Load initial tileset
            await loadTileset('floors');
            resizeRoom();

            // Event listeners
            select.addEventListener('change', (e) => loadTileset(e.target.value));

            document.querySelectorAll('.layer-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.layer-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentLayer = tab.dataset.layer;
                    document.getElementById('wallOptions').classList.toggle('visible', currentLayer === 'walls');
                    document.getElementById('portalOptions').classList.toggle('visible', currentLayer === 'portals');
                    document.getElementById('enemyOptions').classList.toggle('visible', currentLayer === 'enemies');
                    document.getElementById('npcOptions').classList.toggle('visible', currentLayer === 'npcs');
                    updateStatus();
                });
            });

            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    updateStatus();
                });
            });

            // Flip toggle buttons
            document.getElementById('flipHBtn').addEventListener('click', (e) => {
                flipH = !flipH;
                e.target.classList.toggle('active', flipH);
                updatePreview();
                updateStatus();
            });
            document.getElementById('flipVBtn').addEventListener('click', (e) => {
                flipV = !flipV;
                e.target.classList.toggle('active', flipV);
                updatePreview();
                updateStatus();
            });
            // Physical toggle (for objects layer)
            document.getElementById('physicalBtn').addEventListener('click', (e) => {
                physical = !physical;
                e.target.classList.toggle('active', physical);
                updateStatus();
            });

            // Room canvas events
            canvas.addEventListener('mousedown', onCanvasMouseDown);
            canvas.addEventListener('mousemove', onCanvasMouseMove);
            canvas.addEventListener('mouseup', onCanvasMouseUp);
            canvas.addEventListener('mouseleave', onCanvasMouseUp);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Tileset palette events
            const tilesetWrapper = document.getElementById('tilesetWrapper');
            tilesetWrapper.addEventListener('mousemove', onTilesetMouseMove);
            tilesetWrapper.addEventListener('mouseleave', onTilesetMouseLeave);
            tilesetWrapper.addEventListener('click', onTilesetClick);

            document.getElementById('tileDisplaySize').addEventListener('change', (e) => {
                displayTileSize = parseInt(e.target.value);
                resizeRoom();
            });

            document.getElementById('paletteScale').addEventListener('change', (e) => {
                paletteScale = parseInt(e.target.value);
                renderPalette();
            });

            // Load server zones list
            refreshServerZones();

            updateStatus();
        }

        async function loadTileset(key) {
            currentTileset = key;
            const ts = TILESETS[key];
            if (!ts) return;

            if (!tilesetImages[key]) {
                const img = new Image();
                await new Promise((resolve) => {
                    img.onload = resolve;
                    img.onerror = resolve;
                    img.src = ts.path;
                });
                tilesetImages[key] = img;
            }

            renderPalette();
            updateSelectedHighlight();
        }

        function renderPalette() {
            const img = tilesetImages[currentTileset];
            if (!img) return;

            const scaledWidth = img.width * paletteScale;
            const scaledHeight = img.height * paletteScale;

            // Update tileset image
            const tilesetImg = document.getElementById('tilesetImage');
            tilesetImg.src = img.src;
            tilesetImg.style.width = scaledWidth + 'px';
            tilesetImg.style.height = scaledHeight + 'px';

            // Draw grid overlay
            const gridCanvas = document.getElementById('tilesetGridOverlay');
            gridCanvas.width = scaledWidth;
            gridCanvas.height = scaledHeight;
            const gridCtx = gridCanvas.getContext('2d');

            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            gridCtx.lineWidth = 1;

            const scaledTileSize = TILE_SIZE * paletteScale;
            for (let x = 0; x <= scaledWidth; x += scaledTileSize) {
                gridCtx.beginPath();
                gridCtx.moveTo(x + 0.5, 0);
                gridCtx.lineTo(x + 0.5, scaledHeight);
                gridCtx.stroke();
            }
            for (let y = 0; y <= scaledHeight; y += scaledTileSize) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y + 0.5);
                gridCtx.lineTo(scaledWidth, y + 0.5);
                gridCtx.stroke();
            }

            updateSelectedHighlight();
        }

        function getTilesetCoords(e) {
            const wrapper = document.getElementById('tilesetWrapper');
            const rect = wrapper.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scaledTileSize = TILE_SIZE * paletteScale;

            return {
                tileX: Math.floor(x / scaledTileSize),
                tileY: Math.floor(y / scaledTileSize),
                pixelX: Math.floor(x / scaledTileSize) * scaledTileSize,
                pixelY: Math.floor(y / scaledTileSize) * scaledTileSize
            };
        }

        function onTilesetMouseMove(e) {
            const coords = getTilesetCoords(e);
            const scaledTileSize = TILE_SIZE * paletteScale;
            const hover = document.getElementById('tilesetHover');

            hover.style.display = 'block';
            hover.style.left = coords.pixelX + 'px';
            hover.style.top = coords.pixelY + 'px';
            hover.style.width = scaledTileSize + 'px';
            hover.style.height = scaledTileSize + 'px';
        }

        function onTilesetMouseLeave() {
            document.getElementById('tilesetHover').style.display = 'none';
        }

        function onTilesetClick(e) {
            const coords = getTilesetCoords(e);
            selectTile(coords.tileX, coords.tileY);
        }

        function updateSelectedHighlight() {
            const highlight = document.getElementById('tilesetSelected');

            if (!selectedTile || selectedTile.tileset !== currentTileset) {
                highlight.style.display = 'none';
                return;
            }

            const scaledTileSize = TILE_SIZE * paletteScale;
            highlight.style.display = 'block';
            highlight.style.left = (selectedTile.tileX * scaledTileSize) + 'px';
            highlight.style.top = (selectedTile.tileY * scaledTileSize) + 'px';
            highlight.style.width = scaledTileSize + 'px';
            highlight.style.height = scaledTileSize + 'px';
        }

        function selectTile(tileX, tileY) {
            selectedTile = { tileset: currentTileset, tileX, tileY };
            updatePreview();
            updateSelectedHighlight();
            updateStatus();
        }

        function updatePreview() {
            if (!selectedTile) return;

            const preview = document.getElementById('selectedTilePreview');
            const pCtx = preview.getContext('2d');
            pCtx.imageSmoothingEnabled = false;
            pCtx.clearRect(0, 0, 48, 48);

            const img = tilesetImages[selectedTile.tileset];
            if (img) {
                pCtx.save();
                if (flipH || flipV) {
                    pCtx.translate(24, 24);
                    pCtx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                    pCtx.drawImage(img, selectedTile.tileX * TILE_SIZE, selectedTile.tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE, -24, -24, 48, 48);
                } else {
                    pCtx.drawImage(img, selectedTile.tileX * TILE_SIZE, selectedTile.tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE, 0, 0, 48, 48);
                }
                pCtx.restore();
            }

            const flipText = (flipH || flipV) ? ` [${flipH ? 'H' : ''}${flipV ? 'V' : ''}]` : '';
            document.getElementById('selectedInfo').innerHTML = `<strong>${selectedTile.tileset}</strong><br>tileX: ${selectedTile.tileX}, tileY: ${selectedTile.tileY}${flipText}`;
        }

        function resizeRoom() {
            roomWidth = parseInt(document.getElementById('roomWidth').value) || 20;
            roomHeight = parseInt(document.getElementById('roomHeight').value) || 15;
            displayTileSize = parseInt(document.getElementById('tileDisplaySize').value) || 32;

            canvas.width = roomWidth * displayTileSize;
            canvas.height = roomHeight * displayTileSize;
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;

            renderRoom();
            renderGrid();
            updateExport();
        }

        function renderRoom() {
            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw floor tiles
            for (const [key, tile] of Object.entries(roomData.floor)) {
                const [x, y] = key.split(',').map(Number);
                drawTileAt(tile, x, y);
            }

            // Draw objects
            for (const [key, tile] of Object.entries(roomData.objects)) {
                const [x, y] = key.split(',').map(Number);
                drawTileAt(tile, x, y);
                // Draw red border for physical objects
                if (tile.physical) {
                    ctx.strokeStyle = 'rgba(255, 80, 80, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x * displayTileSize + 1, y * displayTileSize + 1, displayTileSize - 2, displayTileSize - 2);
                }
            }

            // Draw walls
            ctx.fillStyle = 'rgba(139, 115, 85, 0.8)';
            ctx.strokeStyle = '#6b5344';
            ctx.lineWidth = 2;
            for (const wall of roomData.walls) {
                const sx = (wall.x / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                const sy = (wall.y / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                const sw = (wall.width / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                const sh = (wall.height / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                ctx.fillRect(sx, sy, sw, sh);
                ctx.strokeRect(sx, sy, sw, sh);
            }

            // Draw portals
            ctx.fillStyle = 'rgba(80, 200, 120, 0.4)';
            ctx.strokeStyle = '#2a9d5c';
            ctx.lineWidth = 2;
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (const portal of roomData.portals) {
                const sx = (portal.x / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                const sy = (portal.y / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                const sw = (portal.width / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                const sh = (portal.height / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                ctx.fillRect(sx, sy, sw, sh);
                ctx.strokeRect(sx, sy, sw, sh);
                // Draw label
                ctx.fillStyle = '#fff';
                ctx.fillText('→ ' + portal.id, sx + sw / 2, sy + sh / 2);
                ctx.fillStyle = 'rgba(80, 200, 120, 0.4)';
            }

            // Draw enemies
            ctx.font = '10px sans-serif';
            for (const enemy of roomData.enemies) {
                const sx = (enemy.x / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                const sy = (enemy.y / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                const radius = displayTileSize / 3;

                ctx.fillStyle = enemy.passive ? 'rgba(200, 150, 80, 0.8)' : 'rgba(200, 60, 60, 0.8)';
                ctx.strokeStyle = enemy.stationary ? '#fff' : '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.fillText('E', sx, sy + 3);
            }

            // Draw NPCs
            for (const npc of roomData.npcs) {
                const sx = (npc.x / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                const sy = (npc.y / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                const radius = displayTileSize / 3;

                ctx.fillStyle = 'rgba(60, 120, 200, 0.8)';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.fillText(npc.name.substring(0, 3), sx, sy + 3);
            }
        }

        function drawTileAt(tile, gridX, gridY) {
            const img = tilesetImages[tile.tileset];
            if (!img) return;

            const destX = gridX * displayTileSize;
            const destY = gridY * displayTileSize;

            if (tile.flipH || tile.flipV) {
                ctx.save();
                ctx.translate(destX + displayTileSize / 2, destY + displayTileSize / 2);
                ctx.scale(tile.flipH ? -1 : 1, tile.flipV ? -1 : 1);
                ctx.drawImage(
                    img,
                    tile.tileX * TILE_SIZE, tile.tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE,
                    -displayTileSize / 2, -displayTileSize / 2, displayTileSize, displayTileSize
                );
                ctx.restore();
            } else {
                ctx.drawImage(
                    img,
                    tile.tileX * TILE_SIZE, tile.tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE,
                    destX, destY, displayTileSize, displayTileSize
                );
            }
        }

        function renderGrid() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            gridCtx.lineWidth = 1;

            for (let x = 0; x <= roomWidth; x++) {
                gridCtx.beginPath();
                gridCtx.moveTo(x * displayTileSize + 0.5, 0);
                gridCtx.lineTo(x * displayTileSize + 0.5, gridCanvas.height);
                gridCtx.stroke();
            }

            for (let y = 0; y <= roomHeight; y++) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y * displayTileSize + 0.5);
                gridCtx.lineTo(gridCanvas.width, y * displayTileSize + 0.5);
                gridCtx.stroke();
            }
        }

        function getGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / displayTileSize);
            const y = Math.floor((e.clientY - rect.top) / displayTileSize);
            return { x: Math.max(0, Math.min(x, roomWidth - 1)), y: Math.max(0, Math.min(y, roomHeight - 1)) };
        }

        function getWorldPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scale = (roomWidth * TILE_SIZE * 3) / canvas.width;
            return {
                x: Math.round((e.clientX - rect.left) * scale),
                y: Math.round((e.clientY - rect.top) * scale)
            };
        }

        function onCanvasMouseDown(e) {
            if (currentLayer === 'walls') {
                wallStart = getWorldPos(e);
                isDrawing = true;
            } else if (currentLayer === 'portals') {
                portalStart = getGridPos(e);
                isDrawing = true;
            } else if (currentLayer === 'enemies') {
                placeEnemy(e);
            } else if (currentLayer === 'npcs') {
                placeNpc(e);
            } else {
                isDrawing = true;
                placeTile(e);
            }
        }

        function onCanvasMouseMove(e) {
            const pos = getGridPos(e);
            document.getElementById('statusBar').textContent =
                `Position: (${pos.x}, ${pos.y}) | Layer: ${currentLayer} | Tool: ${currentTool}`;

            if (isDrawing && currentLayer !== 'walls' && currentLayer !== 'portals') {
                placeTile(e);
            }
        }

        function onCanvasMouseUp(e) {
            if (currentLayer === 'walls' && wallStart && isDrawing) {
                const wallEnd = getWorldPos(e);
                const thickness = parseInt(document.getElementById('wallThickness').value) || 50;

                const x = Math.min(wallStart.x, wallEnd.x);
                const y = Math.min(wallStart.y, wallEnd.y);
                const width = Math.max(thickness, Math.abs(wallEnd.x - wallStart.x));
                const height = Math.max(thickness, Math.abs(wallEnd.y - wallStart.y));

                if (currentTool === 'erase') {
                    // Find and remove wall at position
                    roomData.walls = roomData.walls.filter(w => {
                        const wx = (w.x / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                        const wy = (w.y / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                        const ww = (w.width / (roomWidth * TILE_SIZE * 3)) * canvas.width;
                        const wh = (w.height / (roomHeight * TILE_SIZE * 3)) * canvas.height;
                        const rect = canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        return !(mx >= wx && mx <= wx + ww && my >= wy && my <= wy + wh);
                    });
                } else {
                    roomData.walls.push({ x, y, width, height });
                }

                wallStart = null;
                renderRoom();
                updateExport();
            } else if (currentLayer === 'portals' && portalStart && isDrawing) {
                const portalEnd = getGridPos(e);

                if (currentTool === 'erase') {
                    // Find and remove portal at click position
                    const clickPos = getGridPos(e);
                    roomData.portals = roomData.portals.filter(p => {
                        const pStartX = Math.floor(p.x / (TILE_SIZE * 3));
                        const pStartY = Math.floor(p.y / (TILE_SIZE * 3));
                        const pEndX = Math.floor((p.x + p.width) / (TILE_SIZE * 3));
                        const pEndY = Math.floor((p.y + p.height) / (TILE_SIZE * 3));
                        return !(clickPos.x >= pStartX && clickPos.x <= pEndX &&
                                 clickPos.y >= pStartY && clickPos.y <= pEndY);
                    });
                } else {
                    // Calculate portal bounds in world coordinates
                    const startX = Math.min(portalStart.x, portalEnd.x);
                    const startY = Math.min(portalStart.y, portalEnd.y);
                    const endX = Math.max(portalStart.x, portalEnd.x);
                    const endY = Math.max(portalStart.y, portalEnd.y);

                    const worldX = startX * TILE_SIZE * 3;
                    const worldY = startY * TILE_SIZE * 3;
                    const worldW = (endX - startX + 1) * TILE_SIZE * 3;
                    const worldH = (endY - startY + 1) * TILE_SIZE * 3;

                    // Prompt for target zone ID
                    const targetZone = prompt('Enter target zone ID (e.g., "elevator", "training"):');
                    if (targetZone && targetZone.trim()) {
                        roomData.portals.push({
                            id: targetZone.trim(),
                            x: worldX,
                            y: worldY,
                            width: worldW,
                            height: worldH
                        });
                    }
                }

                portalStart = null;
                renderRoom();
                updateExport();
            }
            isDrawing = false;
        }

        function placeTile(e) {
            const pos = getGridPos(e);
            const key = `${pos.x},${pos.y}`;
            const layer = currentLayer === 'walls' ? 'objects' : currentLayer;

            if (currentTool === 'erase') {
                delete roomData[layer][key];
            } else if (currentTool === 'fill' && selectedTile) {
                // Fill entire layer
                for (let y = 0; y < roomHeight; y++) {
                    for (let x = 0; x < roomWidth; x++) {
                        const tileData = { ...selectedTile, flipH, flipV };
                        if (layer === 'objects') tileData.physical = physical;
                        roomData[layer][`${x},${y}`] = tileData;
                    }
                }
            } else if (selectedTile) {
                const tileData = { ...selectedTile, flipH, flipV };
                if (layer === 'objects') tileData.physical = physical;
                roomData[layer][key] = tileData;
            }

            renderRoom();
            updateExport();
        }

        function placeEnemy(e) {
            const pos = getGridPos(e);
            const worldX = pos.x * TILE_SIZE * 3 + (TILE_SIZE * 3) / 2;
            const worldY = pos.y * TILE_SIZE * 3 + (TILE_SIZE * 3) / 2;

            if (currentTool === 'erase') {
                // Remove enemy near click position
                const clickRadius = TILE_SIZE * 3;
                roomData.enemies = roomData.enemies.filter(enemy => {
                    const dx = enemy.x - worldX;
                    const dy = enemy.y - worldY;
                    return Math.sqrt(dx*dx + dy*dy) > clickRadius;
                });
            } else {
                // Prompt for enemy properties
                const stationary = confirm('Stationary enemy? (OK = Yes, Cancel = No)');
                const passive = confirm('Passive enemy? (OK = Yes, Cancel = No)');
                const hpStr = prompt('HP (default 50):', '50');
                const hp = parseInt(hpStr) || 50;

                roomData.enemies.push({
                    x: worldX,
                    y: worldY,
                    stationary,
                    passive,
                    hp
                });
            }

            renderRoom();
            updateExport();
        }

        function placeNpc(e) {
            const pos = getGridPos(e);
            const worldX = pos.x * TILE_SIZE * 3 + (TILE_SIZE * 3) / 2;
            const worldY = pos.y * TILE_SIZE * 3 + (TILE_SIZE * 3) / 2;

            if (currentTool === 'erase') {
                // Remove NPC near click position
                const clickRadius = TILE_SIZE * 3;
                roomData.npcs = roomData.npcs.filter(npc => {
                    const dx = npc.x - worldX;
                    const dy = npc.y - worldY;
                    return Math.sqrt(dx*dx + dy*dy) > clickRadius;
                });
            } else {
                // Prompt for NPC properties
                const name = prompt('NPC Name:', 'NPC');
                if (!name) return;

                const charStr = prompt('Character number (8-20):', '8');
                const character = Math.max(8, Math.min(20, parseInt(charStr) || 8));

                roomData.npcs.push({
                    x: worldX,
                    y: worldY,
                    name: name.trim(),
                    character
                });
            }

            renderRoom();
            updateExport();
        }

        function clearRoom() {
            if (!confirm('Clear all tiles, walls, portals, enemies and NPCs?')) return;
            roomData = { floor: {}, walls: [], objects: {}, portals: [], enemies: [], npcs: [] };
            renderRoom();
            updateExport();
        }

        function updateExport() {
            const zoneName = document.getElementById('zoneName').value || 'myZone';
            const includeWalls = document.getElementById('includeWalls').checked;
            const includeFloor = document.getElementById('includeFloor').checked;
            const includeObjects = document.getElementById('includeObjects').checked;

            const worldWidth = roomWidth * TILE_SIZE * 3;  // 48px per tile at 3x scale
            const worldHeight = roomHeight * TILE_SIZE * 3;

            let code = `// Zone: ${zoneName}\n`;
            code += `// Size: ${roomWidth}x${roomHeight} tiles (${worldWidth}x${worldHeight} world units)\n\n`;

            // Floor pattern
            if (includeFloor && Object.keys(roomData.floor).length > 0) {
                code += `const ${zoneName.toUpperCase()}_FLOOR = {\n`;
                code += `    width: ${roomWidth},\n`;
                code += `    height: ${roomHeight},\n`;
                code += `    tiles: [\n`;

                for (const [key, tile] of Object.entries(roomData.floor)) {
                    const [x, y] = key.split(',');
                    let tileCode = `        { x: ${x}, y: ${y}, tileset: '${tile.tileset}', tileX: ${tile.tileX}, tileY: ${tile.tileY}`;
                    if (tile.flipH) tileCode += `, flipH: true`;
                    if (tile.flipV) tileCode += `, flipV: true`;
                    tileCode += ` },\n`;
                    code += tileCode;
                }
                code += `    ]\n};\n\n`;
            }

            // Objects (decorations/furniture)
            if (includeObjects && Object.keys(roomData.objects).length > 0) {
                code += `const ${zoneName.toUpperCase()}_OBJECTS = {\n`;
                code += `    width: ${roomWidth},\n`;
                code += `    height: ${roomHeight},\n`;
                code += `    tiles: [\n`;

                for (const [key, tile] of Object.entries(roomData.objects)) {
                    const [x, y] = key.split(',');
                    let tileCode = `        { x: ${x}, y: ${y}, tileset: '${tile.tileset}', tileX: ${tile.tileX}, tileY: ${tile.tileY}`;
                    if (tile.flipH) tileCode += `, flipH: true`;
                    if (tile.flipV) tileCode += `, flipV: true`;
                    if (tile.physical) tileCode += `, physical: true`;
                    tileCode += ` },\n`;
                    code += tileCode;
                }
                code += `    ]\n};\n\n`;
            }

            // Walls
            if (includeWalls && roomData.walls.length > 0) {
                code += `const ${zoneName.toUpperCase()}_WALLS = [\n`;
                for (const wall of roomData.walls) {
                    code += `    { x: ${wall.x}, y: ${wall.y}, width: ${wall.width}, height: ${wall.height} },\n`;
                }
                code += `];\n\n`;
            }

            // Zone definition snippet
            code += `// Add to ZONES object:\n`;
            code += `${zoneName}: {\n`;
            code += `    name: '${zoneName}',\n`;
            code += `    width: ${worldWidth},\n`;
            code += `    height: ${worldHeight},\n`;
            code += `    startX: ${Math.floor(worldWidth / 2)},\n`;
            code += `    startY: ${Math.floor(worldHeight / 2)},\n`;
            if (includeWalls && roomData.walls.length > 0) {
                code += `    walls: ${zoneName.toUpperCase()}_WALLS,\n`;
            }
            if (includeObjects && Object.keys(roomData.objects).length > 0) {
                code += `    objects: ${zoneName.toUpperCase()}_OBJECTS,\n`;
            }
            code += `    portals: [],\n`;
            code += `    npcs: []\n`;
            code += `}\n`;

            document.getElementById('exportCode').value = code;
        }

        function copyExport() {
            const code = document.getElementById('exportCode').value;
            navigator.clipboard.writeText(code).then(() => {
                document.getElementById('statusBar').textContent = 'Code copied to clipboard!';
                setTimeout(updateStatus, 2000);
            });
        }

        function updateStatus() {
            const tileInfo = selectedTile ? `${selectedTile.tileset} (${selectedTile.tileX}, ${selectedTile.tileY})` : 'none';
            const flipInfo = (flipH || flipV) ? ` | Flip: ${flipH ? 'H' : ''}${flipV ? 'V' : ''}` : '';
            const physInfo = (currentLayer === 'objects' && physical) ? ' | Physical' : '';
            document.getElementById('statusBar').textContent =
                `Layer: ${currentLayer} | Tool: ${currentTool} | Selected: ${tileInfo}${flipInfo}${physInfo}`;
        }

        // Load room modal functions
        function showLoadModal() {
            document.getElementById('loadModal').classList.add('visible');
            document.getElementById('loadError').textContent = '';
            document.getElementById('loadCodeInput').value = '';
            document.getElementById('loadCodeInput').focus();
        }

        function hideLoadModal() {
            document.getElementById('loadModal').classList.remove('visible');
        }

        function loadRoomData() {
            const code = document.getElementById('loadCodeInput').value;
            const errorEl = document.getElementById('loadError');
            errorEl.textContent = '';

            try {
                // Parse the code to extract data
                const result = parseRoomCode(code);

                if (!result.floor && !result.objects && !result.walls) {
                    errorEl.textContent = 'No valid room data found. Make sure to paste FLOOR, OBJECTS, or WALLS constants.';
                    return;
                }

                // Update room dimensions if found
                if (result.width && result.height) {
                    roomWidth = result.width;
                    roomHeight = result.height;
                    document.getElementById('roomWidth').value = roomWidth;
                    document.getElementById('roomHeight').value = roomHeight;
                }

                // Clear existing data and load new
                roomData = { floor: {}, walls: [], objects: {} };

                if (result.floor) {
                    result.floor.forEach(tile => {
                        const key = `${tile.x},${tile.y}`;
                        roomData.floor[key] = {
                            tileset: tile.tileset,
                            tileX: tile.tileX,
                            tileY: tile.tileY,
                            flipH: tile.flipH || false,
                            flipV: tile.flipV || false
                        };
                    });
                }

                if (result.objects) {
                    result.objects.forEach(tile => {
                        const key = `${tile.x},${tile.y}`;
                        roomData.objects[key] = {
                            tileset: tile.tileset,
                            tileX: tile.tileX,
                            tileY: tile.tileY,
                            flipH: tile.flipH || false,
                            flipV: tile.flipV || false,
                            physical: tile.physical || false
                        };
                    });
                }

                if (result.walls) {
                    roomData.walls = result.walls;
                }

                // Load any tilesets used
                const usedTilesets = new Set();
                Object.values(roomData.floor).forEach(t => usedTilesets.add(t.tileset));
                Object.values(roomData.objects).forEach(t => usedTilesets.add(t.tileset));

                // Load tilesets then render
                Promise.all([...usedTilesets].map(ts => {
                    if (!tilesetImages[ts] && TILESETS[ts]) {
                        return loadTileset(ts);
                    }
                    return Promise.resolve();
                })).then(() => {
                    resizeRoom();
                    hideLoadModal();
                    document.getElementById('statusBar').textContent = 'Room loaded successfully!';
                    setTimeout(updateStatus, 2000);
                });

            } catch (e) {
                errorEl.textContent = 'Parse error: ' + e.message;
            }
        }

        function parseRoomCode(code) {
            const result = { floor: null, objects: null, walls: null, width: null, height: null };

            // Extract FLOOR tiles array
            const floorMatch = code.match(/_FLOOR\s*=\s*\{[\s\S]*?width:\s*(\d+)[\s\S]*?height:\s*(\d+)[\s\S]*?tiles:\s*\[([\s\S]*?)\]\s*\}/);
            if (floorMatch) {
                result.width = parseInt(floorMatch[1]);
                result.height = parseInt(floorMatch[2]);
                result.floor = parseTilesArray(floorMatch[3]);
            }

            // Extract OBJECTS tiles array
            const objectsMatch = code.match(/_OBJECTS\s*=\s*\{[\s\S]*?width:\s*(\d+)[\s\S]*?height:\s*(\d+)[\s\S]*?tiles:\s*\[([\s\S]*?)\]\s*\}/);
            if (objectsMatch) {
                if (!result.width) result.width = parseInt(objectsMatch[1]);
                if (!result.height) result.height = parseInt(objectsMatch[2]);
                result.objects = parseTilesArray(objectsMatch[3]);
            }

            // Extract WALLS array
            const wallsMatch = code.match(/_WALLS\s*=\s*\[([\s\S]*?)\];/);
            if (wallsMatch) {
                result.walls = parseWallsArray(wallsMatch[1]);
            }

            return result;
        }

        function parseTilesArray(tilesStr) {
            const tiles = [];
            // Match each tile object
            const tilePattern = /\{\s*x:\s*(\d+)\s*,\s*y:\s*(\d+)\s*,\s*tileset:\s*'([^']+)'\s*,\s*tileX:\s*(\d+)\s*,\s*tileY:\s*(\d+)([^}]*)\}/g;
            let match;
            while ((match = tilePattern.exec(tilesStr)) !== null) {
                const tile = {
                    x: parseInt(match[1]),
                    y: parseInt(match[2]),
                    tileset: match[3],
                    tileX: parseInt(match[4]),
                    tileY: parseInt(match[5])
                };
                const extras = match[6];
                if (extras.includes('flipH: true')) tile.flipH = true;
                if (extras.includes('flipV: true')) tile.flipV = true;
                if (extras.includes('physical: true')) tile.physical = true;
                tiles.push(tile);
            }
            return tiles;
        }

        function parseWallsArray(wallsStr) {
            const walls = [];
            const wallPattern = /\{\s*x:\s*(\d+)\s*,\s*y:\s*(\d+)\s*,\s*width:\s*(\d+)\s*,\s*height:\s*(\d+)\s*\}/g;
            let match;
            while ((match = wallPattern.exec(wallsStr)) !== null) {
                walls.push({
                    x: parseInt(match[1]),
                    y: parseInt(match[2]),
                    width: parseInt(match[3]),
                    height: parseInt(match[4])
                });
            }
            return walls;
        }

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('loadModal').classList.contains('visible')) {
                hideLoadModal();
            }
        });

        // Load zone from server
        async function loadExistingRoom(zoneId) {
            if (!zoneId) return;

            // Reset dropdown
            document.getElementById('existingRooms').value = '';

            await loadServerZone(zoneId);
        }

        // Refresh server zones list
        async function refreshServerZones() {
            const select = document.getElementById('existingRooms');
            select.innerHTML = '<option value="">-- Load Zone --</option><option value="" disabled>Loading...</option>';

            try {
                const response = await fetch('/api/zones');
                if (response.ok) {
                    const data = await response.json();
                    const zones = data.zones || data;
                    select.innerHTML = '<option value="">-- Load Zone --</option>';
                    if (zones.length === 0) {
                        select.innerHTML += '<option value="" disabled>No saved zones</option>';
                    } else {
                        zones.forEach(zone => {
                            const opt = document.createElement('option');
                            opt.value = zone;
                            opt.textContent = zone;
                            select.appendChild(opt);
                        });
                    }
                } else {
                    select.innerHTML = '<option value="">-- Load Zone --</option><option value="" disabled>Failed to load</option>';
                }
            } catch (err) {
                select.innerHTML = '<option value="">-- Load Zone --</option><option value="" disabled>Error loading zones</option>';
            }
        }

        // Load zone from server
        async function loadServerZone(zoneId) {
            document.getElementById('statusBar').textContent = 'Loading zone from server...';

            try {
                const response = await fetch(`/api/zones/${zoneId}`);
                if (!response.ok) {
                    throw new Error('Zone not found');
                }

                const zone = await response.json();

                // Set room dimensions
                const tileWorldSize = 48;
                roomWidth = zone.floor?.width || Math.ceil(zone.width / tileWorldSize);
                roomHeight = zone.floor?.height || Math.ceil(zone.height / tileWorldSize);
                document.getElementById('roomWidth').value = roomWidth;
                document.getElementById('roomHeight').value = roomHeight;
                document.getElementById('zoneName').value = zoneId;
                document.getElementById('zoneId').value = zoneId;

                // Clear existing data
                roomData = { floor: {}, walls: [], objects: {} };

                // Load floor tiles
                if (zone.floor?.tiles) {
                    zone.floor.tiles.forEach(tile => {
                        const key = `${tile.x},${tile.y}`;
                        roomData.floor[key] = {
                            tileset: tile.tileset,
                            tileX: tile.tileX,
                            tileY: tile.tileY,
                            flipH: tile.flipH || false,
                            flipV: tile.flipV || false
                        };
                    });
                }

                // Load objects
                if (zone.objects?.tiles) {
                    zone.objects.tiles.forEach(tile => {
                        const key = `${tile.x},${tile.y}`;
                        roomData.objects[key] = {
                            tileset: tile.tileset,
                            tileX: tile.tileX,
                            tileY: tile.tileY,
                            flipH: tile.flipH || false,
                            flipV: tile.flipV || false,
                            physical: tile.physical || false
                        };
                    });
                }

                // Load walls
                if (zone.walls) {
                    roomData.walls = zone.walls.slice();
                }

                // Load portals
                if (zone.portals) {
                    roomData.portals = zone.portals.slice();
                }

                // Load enemies
                if (zone.enemies) {
                    roomData.enemies = zone.enemies.slice();
                }

                // Load NPCs
                if (zone.npcs) {
                    roomData.npcs = zone.npcs.slice();
                }

                // Load all required tilesets
                const usedTilesets = new Set();
                Object.values(roomData.floor).forEach(t => usedTilesets.add(t.tileset));
                Object.values(roomData.objects).forEach(t => usedTilesets.add(t.tileset));

                await Promise.all([...usedTilesets].map(ts => {
                    if (!tilesetImages[ts] && TILESETS[ts]) {
                        return loadTileset(ts);
                    }
                    return Promise.resolve();
                }));

                resizeRoom();
                document.getElementById('statusBar').textContent = `Loaded zone: ${zoneId}`;
                setTimeout(updateStatus, 2000);

            } catch (err) {
                alert('Failed to load zone: ' + err.message);
                updateStatus();
            }
        }

        // Save zone to server
        async function saveToServer() {
            const zoneIdInput = document.getElementById('zoneId');
            if (!zoneIdInput) {
                alert('Error: zoneId input not found');
                return;
            }

            const zoneId = zoneIdInput.value.trim();

            if (!zoneId) {
                alert('Please enter a zone ID');
                return;
            }

            // Validate zone ID format (lowercase, no spaces)
            if (!/^[a-z][a-z0-9_-]*$/.test(zoneId)) {
                alert('Zone ID must start with a letter and contain only lowercase letters, numbers, hyphens, and underscores');
                return;
            }

            const worldWidth = roomWidth * TILE_SIZE * 3;
            const worldHeight = roomHeight * TILE_SIZE * 3;

            // Build floor tiles array
            const floorTiles = [];
            for (const [key, tile] of Object.entries(roomData.floor)) {
                const [x, y] = key.split(',').map(Number);
                const tileData = { x, y, tileset: tile.tileset, tileX: tile.tileX, tileY: tile.tileY };
                if (tile.flipH) tileData.flipH = true;
                if (tile.flipV) tileData.flipV = true;
                floorTiles.push(tileData);
            }

            // Build objects tiles array
            const objectTiles = [];
            for (const [key, tile] of Object.entries(roomData.objects)) {
                const [x, y] = key.split(',').map(Number);
                const tileData = { x, y, tileset: tile.tileset, tileX: tile.tileX, tileY: tile.tileY };
                if (tile.flipH) tileData.flipH = true;
                if (tile.flipV) tileData.flipV = true;
                if (tile.physical) tileData.physical = true;
                objectTiles.push(tileData);
            }

            // Build zone data object
            const zoneData = {
                name: zoneId,
                width: worldWidth,
                height: worldHeight,
                startX: Math.floor(worldWidth / 2),
                startY: Math.floor(worldHeight / 2),
                floor: {
                    width: roomWidth,
                    height: roomHeight,
                    tiles: floorTiles
                },
                objects: {
                    width: roomWidth,
                    height: roomHeight,
                    tiles: objectTiles
                },
                walls: roomData.walls,
                portals: roomData.portals,
                npcs: roomData.npcs,
                enemies: roomData.enemies
            };

            document.getElementById('statusBar').textContent = 'Saving to server...';

            try {
                const response = await fetch(`/api/zones/${zoneId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(zoneData)
                });

                if (response.ok) {
                    document.getElementById('statusBar').textContent = `Zone "${zoneId}" saved successfully!`;
                    refreshServerZones();
                    setTimeout(updateStatus, 3000);
                } else {
                    const error = await response.text();
                    alert('Failed to save zone: ' + error);
                    updateStatus();
                }
            } catch (err) {
                alert('Error saving zone: ' + err.message);
                updateStatus();
            }
        }

        // Start
        init();
    </script>
</body>
</html>
